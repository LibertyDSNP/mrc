# Capacity Provider Boost Implementation

## Overview

This document describes a new type of staking which allows token holders to stake FRQCY and split rewards with a Provider the staker chooses.

Currently, when staking token for Capacity, the only choice is to assign all the generated Capacity to the designated target.
The target, who must be a Provider, may then spend this Capacity to pay for specific transactions. This is called **Maximized Capacity** staking.

In this new type of staking, called **Provider Boosting**, the Provider receives a reward in Capacity and the staker receives a periodic return in FRQCY token.
The amount of Capacity that the Provider would receive in such case is a less than what they would get from a `MaximumCapacity` stake.

The period of Capacity replenishment - the `Epoch` - and the period of token reward - the `RewardEra`- are different.
Epochs much necessarily be much shorter than rewards because Capacity replenishment needs to be multiple times a day to meet the needs of a high traffic network, and to allow Providers the ability to delay transactions to a time of day with lower network activity if necessary.
Reward eras need to be on a much longer scale, such as every two weeks, because there are potentially orders of magnitude more stakers, and calculating rewards is computationally more intensive than updating Capacity balances for the comparatively few Providers.
In addition, this lets the chain to store Reward history for much longer rather than forcing people to have to take steps to claim rewards.

### Diagram

This illustrates roughly -- not to scale and **NOT reflecting actual reward amounts** -- how Provider Boost staking is expected to work. Just like the current staking behavior, now called Maximium staking, The Capacity generated by staking is added to the Provider's Capacity ledger immediately so it can be used right away. The amount staked is locked in Alice's account, preventing transfer.

Provider Boost token rewards are earned only for token staked for a complete Reward Era. So Alice does not begin earning rewards until Reward Era 5 in the diagram, and this means Alice must wait until Reward Era 6 to claim rewards for Reward Era 5. Unclaimed reward amounts are actually not minted or transferred until they are claimed, and may also not be calculated until then, depending on the economic model.

This process will be described in more detail in the Economic Model Design Document.

### NOTE: Actual reward amounts may differ; amounts are for illustration purposes only

![Provider boosted staking](https://github.com/frequency-chain/frequency/assets/502640/ffb632f2-79c2-4a09-a906-e4de02e4f348)

The proposed feature is a design for staking FRQCY token in exchange for Capacity and/or FRQCY.
It is specific to the Frequency Substrate parachain.
It consists of enhancements to the capacity pallet, needed traits and their implementations, and needed runtime configuration.

This does _not_ outline the economic model for Provider Boosting; it describes the economic model as a black box, i.e. an interface.

## Context and Scope:

The Frequency Transaction Payment system allows certain transactions on chain to be paid for with Capacity. Accounts that wish to pay with Capacity must:

1. Have an [MSA](https://github.com/frequency-chain/frequency/blob/main/designdocs/accounts.md)
2. Be a [Provider](https://github.com/frequency-chain/frequency/blob/main/designdocs/provider_registration.md) (see also [Provider Permissions and Grants](https://github.com/frequency-chain/frequency/blob/main/designdocs/provider_permissions.md))
3. Stake a minimum amount of FRQCY (on mainnet, UNIT on Rococo testnet) token to receive [Capacity](https://github.com/frequency-chain/frequency/blob/main/designdocs/capacity.md).

# Problem Statement

This document outlines how to implement the Staking for Rewards feature described in [Capacity Staking Rewards Economic Model](https://github.com/frequency-chain/frequency/blob/main/designdocs/provider_boosting_economic_model.md).

## Glossary

1. **FRQCY**: the native token of Frequency, a Substrate parachain in the Polkdaot blockhain ecosystem.
1. **Capacity**: the non-transferrable utility token which can be used only to pay for certain Frequency transactions.
1. **Account**: a Frequency System Account controlled by a private key and addressed by a public key, having at least a minimum balance (currently 0.01 FRQCY).
1. **Stake** (verb): to lock some amount of a token against transfer for a period of time in exchange for some reward.
1. **RewardEra**: the time period (TBD in blocks) that Provider Boost reweards are based upon. `RewardEra` is to distinguish it easily from Substrate's staking pallet Era, or the index of said time period.
1. **Staking Reward**: a per-RewardEra share of a staking reward pool of FRQCY tokens for a given staking account.
1. **Reward Pool**: a fixed amount of FRQCY that can be minted for rewards each RewardEra and distributed to stakers.
1. **ProviderBoostRewardsProvider**: a trait that encapsulates the economic model for Provider Boosting, providing functionality for calculating the reward pool and Provider Boosting.

## Staking Token Rewards

### StakingAccountDetails --> StakingDetails

A new field, `staking_type` is added to indicate the type of staking the Account holder is doing in relation to this target.
Staking type may be `MaximumCapacity` or `ProviderBoost`. `MaximumCapacity` is the default value for `staking_type` and maps to 0.

This is a second version of this storage, to replace StakingAccountDetails, and StakingAccountDetails data will need to be migrated.

```rust
pub struct StakingDetails<T: Config> {
	/// The amount a Staker has staked, minus the sum of all tokens in `unlocking`.
	pub active: BalanceOf<T>,
	/// The type of staking for this staking account
	pub staking_type: StakingType,
}
```

### ProviderBoostHistories

```rust
	/// Individual history for each account that has Provider-Boosted.
	#[pallet::storage]
	#[pallet::getter(fn get_staking_history_for)]
	pub type ProviderBoostHistories<T: Config> =
		StorageMap<_, Twox64Concat, T::AccountId, ProviderBoostHistory<T>>;
```

**Unstaking thaw period**
Changes the thaw period to begin at the first block of next RewardEra instead of immediately.

### Changes to extrinsics

#### stake

The parameters for the `stake` extrinsic remain the same and the behavior is the same, in that this creates or adds
more token to a staker-target relationship with type `MaximiumCapacity`.
However, if one calls `stake` with a `target` that `origin` already has a staker-target relationsip with,
it is _not_ a `MaximumCapacity` staking type, it will error with `Error::CannotChangeStakingType`.

This means that a single Account Id must choose between staking for Maximum Capacity or staking for Provider Boost + Rewards.
Those who wish to do both types of staking must use two different accounts, one for each purpose.

#### unstake

The unstake parameters are the same, and unstake behavior is the same for `MaximumCapacity` as before, however
for a `ProviderBoost` staker-target relationship, the behavior must be different. The Provider-Boost account must 
first claim all unpaid rewards before an unstake can succeed.

```rust
pub fn unstake(
    origin: OriginFor<T>,
    target: MessageSourceId,
    requested_amount: BalanceOf<T>,
) -> DispatchResult {}

```

### NEW: ProviderBoostRewardsProvider - Economic Model trait
The ProviderBoostRewardsProvider trait implementation depends on the chosen economic model and must
implement the following:

```rust
/// A trait that provides the Economic Model for Provider Boosting.
pub trait ProviderBoostRewardsProvider<T: Config> {
	/// the AccountId this provider is using
	type AccountId;

	/// the range of blocks over which a Reward Pool is determined and rewards are paid out
	type RewardEra;

	///  The hasher to use for proofs
	type Hash;

	/// The type for currency
	type Balance;

	/// Return the size of the reward pool using the current economic model
	fn reward_pool_size(total_staked: BalanceOf<T>) -> BalanceOf<T>;

	/// Calculate the reward for a single era.  We don't care about the era number,
	/// just the values.
	fn era_staking_reward(
		era_amount_staked: BalanceOf<T>, // how much individual staked for a specific era
		era_total_staked: BalanceOf<T>,  // how much everyone staked for the era
		era_reward_pool_size: BalanceOf<T>, // how much token in the reward pool that era
	) -> BalanceOf<T>;


	/// Return the effective amount when staked for a Provider Boost
	/// The amount is multiplied by a factor > 0 and < 1.
	fn capacity_boost(amount: BalanceOf<T>) -> BalanceOf<T>;
}
```

### NEW: Config items
The list below is not inclusive. Other structures and storage may be needed to support required
functionality.

```rust
pub trait Config: frame_system::Config {
    // ...

    /// A period of `EraLength` blocks in which a Staking Pool applies and
    /// when Provider Boost rewards may be earned.
    type RewardEra:  Parameter
                + Member
                + MaybeSerializeDeserialize
                + MaybeDisplay
                + AtLeast32BitUnsigned
                + Default
                + Copy
                + sp_std::hash::Hash
                + MaxEncodedLen
                + TypeInfo;
    /// The number of blocks in a Staking RewardEra
    type EraLength: Get<u32>;

    /// The maximum number of eras over which one can claim rewards
    type ProviderBoostHistoryLimit: Get<u32>;

    /// The trait providing the ProviderBoost economic model calculations and values
    type RewardsProvider: ProviderBoostRewardsProvider;

    /// The fixed size of the reward pool in each Reward Era.
    type RewardPoolEachEra: Get<BalanceOf<Self>>;

    /// the percentage cap per era of an individual Provider Boost reward
    type RewardPercentCap: Get<Permill>;

};
```


### NEW: ProviderBoostRewardPools, CurrentEraProviderBoostTotal
The storage of the total amount staked for the ProviderBoostHistoryLimit number of eras is divided into chunks of
BoundedBTreeMaps, which store Key = RewardEra, Value = Total stake for that era.  The chunks are updated in rotating fashion
in order to minimize reads and writes for listing individual rewards, claiming individual rewards, and changing to a 
new Reward Era, when necessary, during `on_initialize`.

```rust
	/// Reward Pool history is divided into chunks of size RewardPoolChunkLength.
	/// ProviderBoostHistoryLimit is the total number of items, the key is the
	/// chunk number.
	#[pallet::storage]
	#[pallet::getter(fn get_reward_pool_chunk)]
	pub type ProviderBoostRewardPools<T: Config> =
		StorageMap<_, Twox64Concat, u32, RewardPoolHistoryChunk<T>>;

	/// How much is staked this era
	#[pallet::storage]
	pub type CurrentEraProviderBoostTotal<T: Config> = StorageValue<_, BalanceOf<T>, ValueQuery>;
```

### NEW: CurrentEra, RewardEraInfo

Incremented, like CurrentEpoch, tracks the current RewardEra number and the block when it started.
Storage is whitelisted because it's accessed every block and would improperly adversely impact all benchmarks.

```rust
#[pallet::storage]
#[pallet::whitelist_storage]
#[pallet::getter(fn get_current_era)]
/// Similar to CurrentEpoch
pub type CurrentEraInfo<T:Config> = StorageValue<_, T::RewardEraInfo, ValueQuery>;

pub struct RewardEraInfo<RewardEra, BlockNumber> {
    /// the index of this era
    pub current_era: RewardEra,
    /// the starting block of this era
    pub era_start: BlockNumber,
}
```

### NEW: Error enums

```rust
pub enum Error<T> {
    /// ...
    /// Staker tried to change StakingType on an existing account
    CannotChangeStakingType,
    /// The Era specified is too far in the past or is in the future
    EraOutOfRange,
    /// Attempted to retarget but from and to Provider MSA Ids were the same
    CannotRetargetToSameProvider,
    /// There are no rewards eligible to claim.  Rewards have expired, have already been
    /// claimed, or the first ProviderBoost occurred in the current era.
    NoRewardsEligibleToClaim,
    /// Caller must claim rewards before unstaking.
    MustFirstClaimRewards,
    /// Too many change_staking_target calls made in this RewardEra.
    MaxRetargetsExceeded,
    /// Account either has no staking account at all or it is not a ProviderBoost type 
    NotAProviderBoostAccount,
}
```

### NEW Extrinsics

#### provider_boost(origin, target, amount)

Like `stake`, except this extrinsic creates or adds staked token to a `ProviderBoost` type staker-target relationship.
In the case of an increase in stake, `staking_type` MUST be a `ProviderBoost` type, or else it will error with `Error::CannotChangeStakingType`.

This means that a single Account Id (origin) must choose between staking for Maximum Capacity or staking for Provider Boost + Rewards.
Those who wish to do both types of staking must use two different accounts, one for each purpose.


```rust
pub fn provider_boost(
    origin: OriginFor<T>,
    target: MessageSourceId,
    amount: BalanceOf<T>,
) -> DispatchResult {}
```

#### 1. claim_rewards(origin)
Mints and transfers all unclaimed rewards to origin.
The event `StakingRewardClaimed` is emitted with the parameters of the extrinsic.


```rust
/// Claim all outstanding Provider Boost rewards, up to ProviderBoostHistoryLimit Reward Eras 
/// in the past.  Accounts should check for unclaimed rewards before calling this extrinsic
/// to avoid needless transaction fees.
///  Errors:
///     - NotAProviderBoostAccount:  if Origin has nothing staked for ProviderBoost
///     - NothingToClaim:  if Origin has no unclaimed rewards to pay out.
#[pallet::call_index(n)]
pub fn claim_staking_reward(
   origin: OriginFor<T>,
);
```

#### 3. change_staking_target(origin, from, to, amount)

Changes a staking account detail's target MSA Id to a new one by `amount`
Rules for this are similar to unstaking; if `amount` would leave less than the minimum staking amount for the `from` target, the entire amount is retargeted.
No more than `T::MaxUnlockingChunks` staking amounts may be retargeted within this Thawing Period.
Each call creates one chunk. Emits a `StakingTargetChanged` event with the parameters of the extrinsic.

```rust
/// Sets the target of the staking capacity to a new target.
/// This adds a chunk to `StakingDetails.stake_change_unlocking chunks`, up to `T::MaxUnlockingChunks`.
/// The staked amount and Capacity generated by `amount` originally targeted to the `from` MSA Id is reassigned to the `to` MSA Id.
/// Does not affect unstaking process or additional stake amounts.
/// Changing a staking target to a Provider when Origin has nothing staked them will retain the staking type.
/// Changing a staking target to a Provider when Origin has any amount staked to them will error if the staking types are not the same.
/// ### Errors
/// - [`Error::NotAStakingAccount`] if origin does not have a staking account
/// - [`Error::MaxUnlockingChunksExceeded`] if `stake_change_unlocking_chunks` == `T::MaxUnlockingChunks`
/// - [`Error::StakerTargetRelationshipNotFound`] if `from` is not a target for Origin's staking account.
/// - [`Error::StakingAmountBelowMinimum`] if `amount` to retarget is below the minimum staking amount.
/// - [`Error::InsufficientStakingBalance`] if `amount` to retarget exceeds what the staker has targeted to `from` MSA Id.
/// - [`Error::InvalidTarget`] if `to` does not belong to a registered Provider.
/// - [`Error::CannotChangeStakingType`] if origin already has funds staked for `to` and the staking type for `from` is different.
#[pallet:call_index(n+1)] // n = current call index in the pallet
pub fn change_staking_target(
    origin: OriginFor<T>,
    from: MessageSourceId,
    to: MessageSourceId,
    amount: BalanceOf<T>
);
```

### NEW: Capacity pallet helper function

#### has_unclaimed_rewards

Returns whether `account_id` can claim a reward at all.
This function will return false if there is no staker-target relationship.
Staking accounts may claim rewards:

- Once per RewardEra - in which all outstanding rewards are paid out.
- Only for funds staked for a complete RewardEra, i.e. the balance at the end of the Era,

```rust
fn has_unclaimed_rewards(account_id: AccountIdOf<T>) -> bool;
```

### NEW RPCS

There are no custom RPCs for the Capacity pallet, so that work will need to be done first.

The form of this will depend on whether the rewards calculation for an individual account is done by the node or externally
with a submitted proof. If externally, then unclaimed rewards would not include an earned amount.

```rust
pub struct UnclaimedRewardInfo<T: Config> {
	/// The Reward Era for which this reward was earned
	pub reward_era: T::RewardEra,
	/// When this reward expires, i.e. can no longer be claimed
	pub expires_at_block: BlockNumberFor<T>,
	/// The amount staked in this era that is eligible for rewards.  Does not count additional amounts
	/// staked in this era.
	pub eligible_amount: BalanceOf<T>,
	/// The amount in token of the reward (only if it can be calculated using only on chain data)
	pub earned_amount: BalanceOf<T>,
}

/// Check what unclaimed rewards origin has and how long they have left to claim them
/// If no unclaimed rewards, returns empty list.
fn check_for_unclaimed_rewards(origin: OriginFor<T>) -> Vec<UnclaimedRewardInfo>;
```
